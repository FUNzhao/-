## ReadWriteLock



- synchronized和ReentrantLock实现的锁是`排他锁`，所谓排他锁就是同一时刻只允许一个线程访问共享资源，但是在平时场景中，我们通常会碰到对于共享资源`读多写少`的场景。对于读场景，每次只允许一个线程访问共享资源，显然这种情况使用排他锁效率就比较低下，那么该如何优化呢？
- 这个时候`读写锁`就应运而生了，读写锁是一种通用技术，并不是Java特有的。从名字来看，读写锁拥有两把锁，`读锁`和`写锁`。读写锁的特点是：同一时刻允许多个线程对共享资源进行读操作；同一时刻只允许一个线程对共享资源进行写操作；当进行写操作时，同一时刻其他线程的读操作会被阻塞；当进行读操作时，同一时刻所有线程的写操作会被阻塞。对于读锁而言，由于同一时刻可以允许多个线程访问共享资源，进行读操作，因此称它为共享锁；而对于写锁而言，同一时刻只允许一个线程访问共享资源，进行写操作，因此称它为排他锁。



ReadWriteLock也是一个接口，提供了readLock和writeLock两种锁的操作机制，一个资源可以被多个线程同时读，或者被一个线程写，但是不能同时存在读和写线程。

**读锁**：共享锁 readLock

**写锁：**独占锁 writeLock

读写锁 ： 一个资源可以被多个读的线程进行访问 ，或者可以被一个写的线程访问，

但是不能同时存在读和写进程 ，读写互斥，读读共享。

读的时候可以多个线程一起读

写的时候只能一个线程写





深入读写锁[读写锁ReadWriteLock的实现原理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/91408261)